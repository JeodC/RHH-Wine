name: Generate Wine Bottles

on:
  schedule:
    - cron: '0 */12 * * *'
  workflow_dispatch:
    inputs:
      force:
        description: 'Force update all bottles'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
  push:
    paths:
      - 'bottles/released/**'

concurrency:
  group: release-bottles
  cancel-in-progress: true

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y zip jq gh

      - name: Prepare environment
        run: |
          ZIP_DIR="$GITHUB_WORKSPACE/temp_bottles"
          mkdir -p "$ZIP_DIR"
          CASK_JSON="$GITHUB_WORKSPACE/docs/winecask.json"
          [ -f "$CASK_JSON" ] || echo "[]" > "$CASK_JSON"

      - name: Determine bottles to process
        id: bottles
        run: |
          if [ "${{ github.event.inputs.force }}" = "true" ]; then
            # Only process top-level bottle directories
            mapfile -t BOTTLES < <(find bottles/released -mindepth 1 -maxdepth 1 -type d)
          else
            mapfile -t CHANGED < <(git diff --name-only HEAD^ HEAD)
            BOTTLES=()
            for f in "${CHANGED[@]}"; do
              if [[ "$f" == bottles/released/* ]]; then
                ROOT_DIR="bottles/released/$(echo "$f" | cut -d'/' -f3)"
                [ -d "$ROOT_DIR" ] && BOTTLES+=("$ROOT_DIR")
              fi
            done
          fi

          # Remove duplicates and sort
          mapfile -t BOTTLES < <(printf "%s\n" "${BOTTLES[@]}" | sort -u)

          echo "Found ${#BOTTLES[@]} bottles to process:"
          printf '  - %s\n' "${BOTTLES[@]}"
          echo "Bottles=${BOTTLES[*]}" >> $GITHUB_OUTPUT

      - name: Process bottles
        if: ${{ steps.bottles.outputs.Bottles != '' }}
        run: |
          ZIP_DIR="$GITHUB_WORKSPACE/temp_bottles"
          CASK_JSON="$GITHUB_WORKSPACE/docs/winecask.json"

          for STAGING_DIR in ${{ steps.bottles.outputs.Bottles }}; do
            BOTTLENAME=$(basename "$STAGING_DIR")
            echo "â†’ Processing $BOTTLENAME"

            # Metadata expected inside nested subfolder with same name
            META_DIR="$STAGING_DIR/$BOTTLENAME"
            BOTTLE_JSON="$META_DIR/bottle.json"

            if [ ! -f "$BOTTLE_JSON" ]; then
              echo "  Skipping $BOTTLENAME: missing $BOTTLE_JSON"
              continue
            fi

            SCREENSHOT=$(find "$META_DIR" -maxdepth 1 -type f \( -iname "screenshot*.png" -o -iname "screenshot*.jpg" -o -iname "screenshot*.jpeg" \) | head -n1)
            if [ ! -f "$SCREENSHOT" ]; then
              echo "  Skipping $BOTTLENAME: no screenshot found"
              continue
            fi

            README=$(find "$META_DIR" -maxdepth 1 -type f \( -iname "README.md" -o -iname "readme.md" \) | head -n1)

            echo "  ðŸ“¦ Zipping bottle â†’ $ZIP_DIR/${BOTTLENAME}.zip"
            (cd "$STAGING_DIR" && zip -r -q "$ZIP_DIR/${BOTTLENAME}.zip" .)

            ZIP_PATH="$ZIP_DIR/${BOTTLENAME}.zip"
            MD5=$(md5sum "$ZIP_PATH" | awk '{print $1}')
            SIZE=$(stat -c %s "$ZIP_PATH")
            SCREENSHOT_URL="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/main/${SCREENSHOT#"$GITHUB_WORKSPACE/"}"

            if [ -f "$README" ]; then
              README_URL="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/main/${README#"$GITHUB_WORKSPACE/"}"
            else
              README_URL=""
            fi

            DOWNLOAD_URL="https://github.com/${GITHUB_REPOSITORY}/releases/download/bottles-latest/${BOTTLENAME}.zip"

            ORIGINAL_JSON=$(cat "$BOTTLE_JSON")

            # Load existing bottle entry if it exists
            EXISTING_ENTRY=$(jq -c --arg name "$BOTTLENAME" '.[] | select((.name | split(".")[0]) == $name)' "$CASK_JSON" || echo "")
            if [ -n "$EXISTING_ENTRY" ]; then
              OLD_MD5=$(echo "$EXISTING_ENTRY" | jq -r '.source.md5 // empty')
              OLD_SIZE=$(echo "$EXISTING_ENTRY" | jq -r '.source.size // empty')
            else
              OLD_MD5=""
              OLD_SIZE=""
            fi

            # Decide whether to bump date_updated
            if [ "$MD5" != "$OLD_MD5" ] || [ "$SIZE" != "$OLD_SIZE" ]; then
              DATE_UPDATED=$(date -u +"%Y-%m-%d")
            else
              DATE_UPDATED=$(echo "$EXISTING_ENTRY" | jq -r '.source.date_updated // empty')
              [ -z "$DATE_UPDATED" ] && DATE_UPDATED=$(date -u +"%Y-%m-%d")
            fi

            BOTTLE_JSON_MERGED=$(jq -n \
              --argjson original "$ORIGINAL_JSON" \
              --arg date_updated "$DATE_UPDATED" \
              --arg download_url "$DOWNLOAD_URL" \
              --arg readme_url "$README_URL" \
              --arg screenshot_url "$SCREENSHOT_URL" \
              --arg size "$SIZE" \
              --arg md5 "$MD5" \
              '$original + {source: {date_updated: $date_updated, download_url: $download_url, screenshot_url: $screenshot_url, readme_url: $readme_url, size: ($size|tonumber), md5: $md5}}'
            )

            TMP=$(mktemp)
            jq --arg bottlename "$BOTTLENAME" --argjson bottlejson "$BOTTLE_JSON_MERGED" \
              'map(select((.name | split(".")[0]) != $bottlename)) + [$bottlejson]' \
              "$CASK_JSON" > "$TMP" && mv "$TMP" "$CASK_JSON"
          done

      - name: Sort bottles by title
        run: |
          CASK_JSON="$GITHUB_WORKSPACE/docs/winecask.json"
          TMP=$(mktemp)
          jq 'sort_by(.attr.title)' "$CASK_JSON" > "$TMP" && mv "$TMP" "$CASK_JSON"

      - name: Ensure release exists
        if: ${{ steps.bottles.outputs.Bottles != '' }}
        env:
          GH_TOKEN: ${{ secrets.TOKEN }}
        run: |
          gh release view bottles-latest --json id &>/dev/null || \
          gh release create bottles-latest --title "Bottles" --notes "Automated release"

      - name: Delete conflicting release assets
        env:
          GITHUB_TOKEN: ${{ secrets.TOKEN }}
        if: ${{ steps.bottles.outputs.Bottles != '' }}
        run: |
          RELEASE_ID=$(gh api repos/${GITHUB_REPOSITORY}/releases/tags/bottles-latest --jq '.id')
          for FILE in temp_bottles/*.zip; do
            NAME=$(basename "$FILE")
            ASSET_ID=$(gh api repos/${GITHUB_REPOSITORY}/releases/$RELEASE_ID/assets --jq ".[] | select(.name==\"$NAME\") | .id" 2>/dev/null || echo "")
            if [ -n "$ASSET_ID" ]; then
              echo "Deleting old asset: $NAME ($ASSET_ID)"
              gh api -X DELETE "repos/${GITHUB_REPOSITORY}/releases/assets/$ASSET_ID" || true
              sleep 3
            fi
          done

      - name: Upload zips with retries
        if: ${{ steps.bottles.outputs.Bottles != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.TOKEN }}
        run: |
          MAX_RETRIES=3
          for FILE in temp_bottles/*.zip; do
            NAME=$(basename "$FILE")
            ATTEMPT=1
            until [ $ATTEMPT -gt $MAX_RETRIES ]; do
              echo "Uploading $NAME (attempt $ATTEMPT)..."
              gh release upload bottles-latest "$FILE" --clobber && break
              echo "Failed to upload $NAME, retrying in 5s..."
              sleep 5
              ATTEMPT=$((ATTEMPT+1))
            done
          done

      - name: Commit winecask.json
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"
          git add docs/winecask.json
          if ! git diff --cached --quiet; then
            git commit -m "Update winecask.json"
            git push
          fi

      - name: Cleanup
        if: always()
        run: rm -rf temp_bottles